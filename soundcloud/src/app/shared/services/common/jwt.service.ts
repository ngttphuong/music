import { Injectable } from '@angular/core';
import { HttpHeaders, HttpClient, HttpResponse } from '@angular/common/http';
import { Observable, from } from 'rxjs';
import { map } from 'rxjs/operators';

import { StringService } from './string.service';
import { env } from '../../../../environments/environment';
import { subtleCrypto } from '../../constants/mozilla-web-api';
import { localStorageName } from '../../constants/local-storage';
import { apiRequestHeader } from '../../constants/api';

@Injectable()
export class JwtService {
	readonly headerBase64: string = 'eyJhbGciOiJIUzI1NiJ9';
	readonly algorithmName: string = 'HMAC';
	readonly hashName: string = subtleCrypto.digest.algorithm.sha256;
	// userUid: string ;
	// secretKey: string;
	readonly timestampApiPath: string = env.apiUrl + "/timestamp";
	readonly localTimestampKey: string = "theMomentOfGettingApiTimestamp";
	readonly timestampCacheExpirationInSeconds: number = 3;

    constructor( private stringService: StringService, private http: HttpClient ) {
        this.loadAuthInfo();
    }

    /**
     * Load auth info from local storage.
     */
    loadAuthInfo() {
        // this.userUid = localStorage.getItem( localStorageName.userUid );
        // this.secretKey = localStorage.getItem( localStorageName.secretKey );
    }

    /**
     * Generate request options with auth info by a secret key.
     * @param {string} A secret key string.
     * @return {Observable<any>} Request options.
     */
    // generateRequestOptions(): Observable<any> {
    //     return from(
    //         this.generateCryptoKey( this.secretKey )
    //             .then(( cryptoKey: CryptoKey ) => { return this.generateToken( this.userUid, cryptoKey ) })
    //             .then(( token: string ) => {
    //                 let headerList: HttpHeaders = new HttpHeaders({
    //                     'Authorization': 'Bearer ' + token,
    //                     'Content-Type': apiRequestHeader.contentType
    //                 });
    //                 return { headers: headerList, observe: 'response' };
    //             })
    //     );
    // }

    /**
     * Generate request options with auth info by a secret key without content type
     * @param {string} A secret key string.
     * @return {Observable<any>} Request options.
     */
    // generateAuthorizationHeader(): Observable<any> {
    //     return from(
    //         this.generateCryptoKey( this.secretKey )
    //             .then(( cryptoKey: CryptoKey ) => { return this.generateToken( this.userUid, cryptoKey ) })
    //             .then(( token: string ) => {
    //                 return new HttpHeaders({
    //                     'Authorization': 'Bearer ' + token
    //                 });
    //             })
    //     );
    // }

    /**
     * Generate JWT.
     * @param {number} userUid - An user account id.
     * @param {CryptoKey} cryptokey - A crypto key generated by secret key from the response of sign-in API.
     * @return {Promise<string>} A base64 encoded JWT header, payload and signature joined by '.'.
     */
    // generateToken( userUid: string, cryptokey: CryptoKey ): Promise<string> {
    //     if ( this.isCachedTimestampValid() ) {
    //         return this.encodeSignatureString( userUid, cryptokey, localStorage.getItem( localStorageName.apiTimestampKey ) );
    //     } else {
    //         return this.getTimestampFromApi().then(
    //             ( response: HttpResponse<string> ) => {
    //                 let apiTimestamp: string = String( response );
    //                 this.saveMomentOfGettingApiTimestamp();
    //                 this.saveApiTimestamp( apiTimestamp );
    //                 return this.encodeSignatureString( userUid, cryptokey, apiTimestamp );
    //             }
    //         );
    //     }
    // }

    /**
     * Generate a crypto key by a secret key.
     * @param {string} A secret key string.
     * @return {Promise<CryptoKey>} A crypto key.
     */
    // generateCryptoKey( secretKey: string ): Promise<CryptoKey> {
    //     return Promise.resolve(
    //         crypto.subtle.importKey(
    //             subtleCrypto.importKeyForSign.format,
    //             this.stringService.stringToUint8Array( secretKey ),
    //             {
    //                 name: this.algorithmName,
    //                 hash: {
    //                     name: this.hashName
    //                 }
    //             },
    //             false,
    //             subtleCrypto.importKeyForSign.usages
    //         ).then(( key: CryptoKey ) => { return key; })
    //     );
    // }

    // private encodeSignatureString( userUid: string, cryptokey: CryptoKey, timestamp: string | null ): Promise<string> {
    //     let jwtPayload: string = `{"sub":"${userUid}","iat":${timestamp}}`;
    //     let jwtHeaderPayloadBase64: string = this.headerBase64 + '.' + this.stringService.encodeBase64( jwtPayload );
    //     return Promise.resolve(
    //         crypto.subtle.sign(
    //             {
    //                 name: this.algorithmName,
    //                 hash: {
    //                     name: this.hashName
    //                 }
    //             },
    //             cryptokey,
    //             this.stringService.stringToUint8Array( jwtHeaderPayloadBase64 )
    //         ).then( ( signatureArrayBuffer: ArrayBuffer ) => {
    //             let signatureUnit8Array: Uint8Array = new Uint8Array( signatureArrayBuffer );
    //             let signatureString: string = this.stringService.uint8ArrayToString( signatureUnit8Array );

    //             return jwtHeaderPayloadBase64 + '.' + this.stringService.encodeBase64( signatureString );
    //         } )
    //     );
    // }

    private getTimestampFromApi(): Promise<HttpResponse<any>> {
        return this.http.get( this.timestampApiPath ).pipe(
            map( ( response: any ) => {
                return response
            } )
        ).toPromise();
    }

}
